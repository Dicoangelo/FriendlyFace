# FriendlyFace — Data Models & Database Schema

## Pydantic Models

All models are defined in `friendlyface/core/models.py` using Pydantic v2 with strict validation.

---

## Enums

### EventType

Every forensic event has a type that identifies what operation produced it.

```python
class EventType(str, Enum):
    TRAINING_START       = "training_start"
    TRAINING_COMPLETE    = "training_complete"
    MODEL_REGISTERED     = "model_registered"
    INFERENCE_REQUEST    = "inference_request"
    INFERENCE_RESULT     = "inference_result"
    EXPLANATION_GENERATED = "explanation_generated"
    BIAS_AUDIT           = "bias_audit"
    CONSENT_RECORDED     = "consent_recorded"
    CONSENT_UPDATE       = "consent_update"
    BUNDLE_CREATED       = "bundle_created"
    FL_ROUND             = "fl_round"
    SECURITY_ALERT       = "security_alert"
    COMPLIANCE_REPORT    = "compliance_report"
```

### ProvenanceRelation

Relationships between provenance nodes in the DAG.

```python
class ProvenanceRelation(str, Enum):
    DERIVED_FROM   = "derived_from"    # e.g., model derived from dataset
    GENERATED_BY   = "generated_by"    # e.g., inference generated by model
    USED           = "used"            # e.g., explanation used inference result
    ATTRIBUTED_TO  = "attributed_to"   # e.g., event attributed to actor
```

### BundleStatus

Lifecycle state of a forensic bundle.

```python
class BundleStatus(str, Enum):
    PENDING   = "pending"    # Bundle created, not yet sealed
    COMPLETE  = "complete"   # Bundle sealed with hash
    VERIFIED  = "verified"   # Bundle has passed verification
    TAMPERED  = "tampered"   # Bundle failed verification
```

---

## Core Models

### ForensicEvent

The fundamental record type. Every operation across all 6 layers produces one.

| Field | Type | Description |
|-------|------|-------------|
| `id` | `UUID` | Auto-generated unique identifier |
| `event_type` | `EventType` | What operation produced this event |
| `timestamp` | `datetime` | UTC timestamp of creation |
| `actor` | `str` | Who/what initiated the operation |
| `payload` | `dict[str, Any]` | Arbitrary JSON payload with operation details |
| `previous_hash` | `str` | Hash of the preceding event (`"GENESIS"` for first) |
| `event_hash` | `str` | `SHA256(canonical_json(content) + previous_hash)` |
| `sequence_number` | `int` | Strictly ordered position in the chain |

**Methods:**
- `seal()` → Computes `event_hash` and returns self. Must be called before persistence.
- `verify()` → Recomputes the hash and compares. Returns `True` if the event is untampered.

### ProvenanceNode

A node in the provenance DAG tracking data lineage.

| Field | Type | Description |
|-------|------|-------------|
| `id` | `UUID` | Auto-generated unique identifier |
| `entity_type` | `str` | Type of entity (e.g., "dataset", "model", "inference", "fl_round") |
| `entity_id` | `str` | Human-readable entity identifier |
| `created_at` | `datetime` | UTC timestamp |
| `metadata` | `dict[str, Any]` | Entity-specific metadata |
| `parents` | `list[UUID]` | IDs of parent nodes in the DAG |
| `relations` | `list[ProvenanceRelation]` | Relationship types to parents (parallel array) |
| `node_hash` | `str` | Hash of node content for tamper detection |

### ForensicBundle

Self-verifiable evidence package.

| Field | Type | Description |
|-------|------|-------------|
| `id` | `UUID` | Auto-generated unique identifier |
| `created_at` | `datetime` | UTC timestamp |
| `status` | `BundleStatus` | Current lifecycle state |
| `event_ids` | `list[UUID]` | IDs of included forensic events |
| `merkle_root` | `str` | Merkle tree root at bundle creation time |
| `merkle_proofs` | `list[MerkleProof]` | Inclusion proofs for all included events |
| `provenance_chain` | `list[UUID]` | IDs of provenance nodes in the bundle |
| `bias_audit` | `BiasAuditRecord \| None` | Included bias audit (if available) |
| `recognition_artifacts` | `dict \| None` | Layer 1 artifacts |
| `fl_artifacts` | `dict \| None` | Layer 2 artifacts |
| `bias_report` | `dict \| None` | Layer 4 report |
| `explanation_artifacts` | `dict \| None` | Layer 5 artifacts |
| `zk_proof_placeholder` | `str \| None` | Schnorr ZK proof JSON |
| `did_credential_placeholder` | `str \| None` | Ed25519 VC JSON |
| `bundle_hash` | `str` | Hash covering all bundle contents |

### MerkleProof

Inclusion proof for a single event in the Merkle tree.

| Field | Type | Description |
|-------|------|-------------|
| `event_id` | `UUID` | The event being proved |
| `leaf_index` | `int` | Position in the tree |
| `siblings` | `list[str]` | Sibling hashes for reconstruction |
| `root` | `str` | Expected root hash |

### BiasAuditRecord

Result of a fairness audit.

| Field | Type | Description |
|-------|------|-------------|
| `id` | `UUID` | Auto-generated unique identifier |
| `event_id` | `UUID \| None` | Associated forensic event |
| `timestamp` | `datetime` | When the audit was performed |
| `demographic_parity_gap` | `float` | Difference in recognition rates across groups |
| `equalized_odds_gap` | `float` | Difference in error rates across groups |
| `groups_evaluated` | `list[str]` | Demographic groups included |
| `compliant` | `bool` | Whether metrics are within thresholds |
| `details` | `dict[str, Any]` | Per-group breakdown and raw metrics |

---

## Utility Functions

```python
def canonical_json(data: dict[str, Any]) -> str:
    """Deterministic JSON serialization for hashing.
    Uses sort_keys=True and compact separators."""

def sha256_hex(data: str) -> str:
    """SHA-256 hex digest of a UTF-8 string."""
```

---

## Database Schema (SQLite)

### forensic_events

```sql
CREATE TABLE forensic_events (
    id              TEXT PRIMARY KEY,
    event_type      TEXT NOT NULL,
    timestamp       TEXT NOT NULL,
    actor           TEXT NOT NULL,
    payload         TEXT NOT NULL DEFAULT '{}',
    previous_hash   TEXT NOT NULL DEFAULT 'GENESIS',
    event_hash      TEXT NOT NULL,
    sequence_number INTEGER NOT NULL
);
```

### provenance_nodes

```sql
CREATE TABLE provenance_nodes (
    id          TEXT PRIMARY KEY,
    entity_type TEXT NOT NULL,
    entity_id   TEXT NOT NULL,
    created_at  TEXT NOT NULL,
    metadata    TEXT NOT NULL DEFAULT '{}',
    parents     TEXT NOT NULL DEFAULT '[]',
    relations   TEXT NOT NULL DEFAULT '[]',
    node_hash   TEXT NOT NULL
);
```

### forensic_bundles

```sql
CREATE TABLE forensic_bundles (
    id                          TEXT PRIMARY KEY,
    created_at                  TEXT NOT NULL,
    status                      TEXT NOT NULL DEFAULT 'pending',
    event_ids                   TEXT NOT NULL DEFAULT '[]',
    merkle_root                 TEXT NOT NULL DEFAULT '',
    merkle_proofs               TEXT NOT NULL DEFAULT '[]',
    provenance_chain            TEXT NOT NULL DEFAULT '[]',
    bias_audit                  TEXT,
    recognition_artifacts       TEXT,
    fl_artifacts                TEXT,
    bias_report                 TEXT,
    explanation_artifacts       TEXT,
    zk_proof_placeholder        TEXT,
    did_credential_placeholder  TEXT,
    bundle_hash                 TEXT NOT NULL DEFAULT ''
);
```

### bias_audits

```sql
CREATE TABLE bias_audits (
    id                      TEXT PRIMARY KEY,
    event_id                TEXT,
    timestamp               TEXT NOT NULL,
    demographic_parity_gap  REAL NOT NULL,
    equalized_odds_gap      REAL NOT NULL,
    groups_evaluated        TEXT NOT NULL DEFAULT '[]',
    compliant               INTEGER NOT NULL DEFAULT 1,
    details                 TEXT NOT NULL DEFAULT '{}'
);
```

### consent_records

```sql
CREATE TABLE consent_records (
    id                TEXT PRIMARY KEY,
    subject_id        TEXT NOT NULL,
    purpose           TEXT NOT NULL,
    granted           INTEGER NOT NULL DEFAULT 1,
    timestamp         TEXT NOT NULL,
    expiry            TEXT,
    revocation_reason TEXT,
    event_id          TEXT
);

CREATE INDEX idx_consent_subject_purpose
    ON consent_records (subject_id, purpose, timestamp);
```

**Note:** Consent records are append-only. There are no `UPDATE` or `DELETE` operations on this table. Revocations are new `INSERT` records with `granted = 0`.

---

## JSON Serialization Notes

- All `UUID` fields are stored as `TEXT` in SQLite (hex string representation)
- All `datetime` fields are stored as ISO 8601 UTC strings
- `payload`, `metadata`, `parents`, `relations`, `event_ids`, `merkle_proofs`, `provenance_chain` are stored as JSON text
- `bias_audit`, layer artifact fields, and crypto fields are stored as JSON text or `NULL`

The `Database` class handles all serialization/deserialization transparently, converting between Pydantic models and SQLite rows.
